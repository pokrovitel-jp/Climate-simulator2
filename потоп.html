<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flood Map Simulation</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; }
    #map { height: 100%; width: 100%; }
    #sliderContainer {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      padding: 10px 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      font-family: sans-serif;
      z-index: 1000;
    }
    #waterLevel { width: 300px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="sliderContainer">
    Water level: <span id="levelText">0</span> meters
    <input type="range" id="waterLevel" min="0" max="100" value="0" step="1">
  </div>

  <script>
    // Глобальные переменные
    let map;
    let floodOverlay;
    let currentWaterLevel = 0;
    let elevationService;
    let lastRequestId = 0;
    let activeElevationRequest = null;
    let isMapLoaded = false;

    // Функция инициализации карты
    function initMap() {
      isMapLoaded = true;
      
      try {
        // Инициализация карты
        map = new google.maps.Map(document.getElementById("map"), {
          center: { lat: 40, lng: 70 },
          zoom: 4,
          mapTypeId: "terrain",
          streetViewControl: false,
          mapTypeControl: false
        });

        // Создание overlay для отображения затопления
        createFloodOverlay();
        
        // Инициализация сервиса высот
        elevationService = new google.maps.ElevationService();
        
        // Настройка обработчиков событий
        setupEventListeners();
        
      } catch (error) {
        console.error("Map initialization error:", error);
      }
    }

    function createFloodOverlay() {
      floodOverlay = new google.maps.OverlayView();
      
      floodOverlay.onAdd = function() {
        const div = document.createElement('div');
        div.style.position = 'absolute';
        div.style.pointerEvents = 'none';
        
        this.canvas = document.createElement('canvas');
        this.canvas.style.width = '100%';
        this.canvas.style.height = '100%';
        div.appendChild(this.canvas);
        
        this.getPanes().overlayLayer.appendChild(div);
        this.div = div;
      };
      
      floodOverlay.draw = function() {
        if (!this.getProjection()) return;
        
        const bounds = map.getBounds();
        if (!bounds) return;
        
        const overlayProjection = this.getProjection();
        const ne = overlayProjection.fromLatLngToDivPixel(bounds.getNorthEast());
        const sw = overlayProjection.fromLatLngToDivPixel(bounds.getSouthWest());
        
        if (!ne || !sw) return;
        
        this.div.style.left = sw.x + 'px';
        this.div.style.top = ne.y + 'px';
        this.div.style.width = (ne.x - sw.x) + 'px';
        this.div.style.height = (sw.y - ne.y) + 'px';
        
        this.canvas.width = Math.max(1, ne.x - sw.x);
        this.canvas.height = Math.max(1, sw.y - ne.y);
        
        safeUpdateFloodOverlay();
      };
      
      floodOverlay.setMap(map);
    }

    function setupEventListeners() {
      const debouncedUpdate = debounce(safeUpdateFloodOverlay, 500);
      
      google.maps.event.addListener(map, 'bounds_changed', debouncedUpdate);
      google.maps.event.addListener(map, 'zoom_changed', debouncedUpdate);
      
      document.getElementById("waterLevel").addEventListener("input", function(e) {
        currentWaterLevel = parseInt(e.target.value);
        document.getElementById("levelText").innerText = currentWaterLevel;
        safeUpdateFloodOverlay();
      });
    }

    function safeUpdateFloodOverlay() {
      if (!isMapLoaded) return;
      updateFloodOverlay();
    }

    function updateFloodOverlay() {
      if (!map || !floodOverlay || !floodOverlay.canvas) return;
      
      const bounds = map.getBounds();
      if (!bounds) return;
      
      const canvas = floodOverlay.canvas;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const ne = bounds.getNorthEast();
      const sw = bounds.getSouthWest();
      const zoom = map.getZoom();
      
      // Оптимизация: уменьшаем плотность точек при большом zoom
      const gridSize = calculateGridSize(zoom);
      
      // Создаем массив точек для запроса высот
      const {locations, gridPoints} = createGridPoints(ne, sw, gridSize, zoom);
      
      if (locations.length === 0) return;
      
      // Отменяем предыдущий запрос, если он есть
      cancelPendingRequest();
      
      const requestId = ++lastRequestId;
      
      try {
        activeElevationRequest = elevationService.getElevationForLocations({
          locations: locations
        }, (results, status) => {
          if (status !== 'OK' || requestId !== lastRequestId) return;
          renderFloodAreas(results, gridPoints, zoom);
        });
      } catch (error) {
        console.error("Elevation service error:", error);
      }
    }

    function calculateGridSize(zoom) {
      if (zoom < 8) return 0.5;
      if (zoom < 10) return 0.2;
      if (zoom < 12) return 0.1;
      return 0.05;
    }

    function createGridPoints(ne, sw, gridSize, zoom) {
      const locations = [];
      const gridPoints = [];
      const maxPoints = getMaxPoints(zoom);
      let pointCount = 0;
      
      for (let lat = sw.lat(); lat <= ne.lat() && pointCount < maxPoints; lat += gridSize) {
        for (let lng = sw.lng(); lng <= ne.lng() && pointCount < maxPoints; lng += gridSize) {
          locations.push(new google.maps.LatLng(lat, lng));
          gridPoints.push({ lat, lng });
          pointCount++;
        }
      }
      
      return {locations, gridPoints};
    }

    function getMaxPoints(zoom) {
      // Ограничиваем количество точек в зависимости от zoom
      if (zoom < 8) return 500;
      if (zoom < 10) return 1000;
      if (zoom < 12) return 2000;
      return 3000;
    }

    function cancelPendingRequest() {
      if (activeElevationRequest) {
        try {
          // В новых версиях API нет метода cancel(), поэтому просто игнорируем
          if (typeof activeElevationRequest.cancel === 'function') {
            activeElevationRequest.cancel();
          }
        } catch (e) {
          console.warn("Error canceling request:", e);
        }
        activeElevationRequest = null;
      }
    }

    function renderFloodAreas(results, gridPoints, zoom) {
      if (!floodOverlay || !floodOverlay.canvas) return;
      
      const ctx = floodOverlay.canvas.getContext('2d');
      const overlayProjection = floodOverlay.getProjection();
      ctx.fillStyle = 'rgba(65, 105, 225, 0.6)';
      
      const pointSize = calculatePointSize(zoom);
      
      for (let i = 0; i < results.length; i++) {
        if (results[i] && results[i].elevation <= currentWaterLevel) {
          const point = overlayProjection.fromLatLngToDivPixel(
            new google.maps.LatLng(gridPoints[i].lat, gridPoints[i].lng)
          );
          
          if (!point) continue;
          
          ctx.fillRect(
            Math.round(point.x - pointSize/2),
            Math.round(point.y - pointSize/2),
            pointSize,
            pointSize
          );
        }
      }
    }

    function calculatePointSize(zoom) {
      if (zoom < 8) return 10;
      if (zoom < 10) return 6;
      if (zoom < 12) return 4;
      return 2;
    }

    function debounce(func, wait) {
      let timeout;
      return function() {
        const context = this, args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          func.apply(context, args);
        }, wait);
      };
    }

    // Обработка ошибок загрузки API
    function handleMapError() {
      console.error("Failed to load Google Maps API");
      document.getElementById("map").innerHTML = 
        '<div style="padding:20px;color:red">Error loading Google Maps. Please check your internet connection.</div>';
    }

    // Проверяем, загрузился ли API
    function checkAPILoaded() {
      if (!window.google || !window.google.maps) {
        setTimeout(checkAPILoaded, 100);
        return;
      }
      window.initMap = initMap;
    }

    // Инициализация проверки загрузки API
    checkAPILoaded();
  </script>

  <!-- Загрузка Google Maps API с обработкой ошибок -->
  <script>
    (function() {
      const script = document.createElement('script');
      script.src = 'https://maps.googleapis.com/maps/api/js?key=AIzaSyAT4ONNU2QJLsazxrIlCqNJgbBC3anVunQ&libraries=visualization,elevation&callback=initMap';
      script.async = true;
      script.defer = true;
      script.onerror = handleMapError;
      document.head.appendChild(script);
    })();
  </script>
</body>
</html>

